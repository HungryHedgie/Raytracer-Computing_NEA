#	Hardcoded

tolerance.MaxIterations	#	Max times we can jump forward for a given ray
tolerance.MaxDistance	#	We will stop checking for an intersection if we jump higher than this in one iteration
tolerance.MinDistance	#	If the closest object is closer than this, we assume we are intersecting it

FUNCTION determineIntersections(rayOrigin, rayDirection, previousShape)
	rayDirection <= normalise(rayDirection)	#	We want to normalise rayDirection
	
	currPos <= rayOrigin
	
	searching <= true
	iterationCount <= 0
	exitCode <= null
	closestObject <= null
	
	WHILE searching is true THEN
		#	Find closest surface
		lowestDistance = tolerance.MaxDistance
		FOR object IN all shapes and lights				#	SDF = Signed Distance Function
			IF object is not previousShape THEN
				newDistance = object.SDF(currPos)
				
				IF newDistance is less than lowestDistance THEN
					lowestDistance = newDistance
					closestObject = object
				END IF
		END FOR
		#	Iteration count is used to determine
		iterationCount <= iterationCount + 1
		
		#	Use closest surface to find new position
		currPos <= currPos + rayDirection * lowestDistance
		
		#	Tolerance check, have we travelled over the max distance, or gone through too many iterations?
		IF iterationCount > tolerance.MaxIterations OR lowestDistance equals tolerance.MaxDistance THEN
			searching <= false
			exitCode <= NO_INTERSECTION
		ELSE IF lowestDistance <= tolerance.MinDistance THEN
			searching <= false
			exitCode <= INTERSECTION
		END IF
	END WHILE
	
	
	return (exitInfo, CurrPos, closestObject)